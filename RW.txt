-------------------------------------------------------------------------------

(1) "A Theory of Lazy Imperative Timing"
Eric C. R. Hehner (U of Toronto)
Refine'18 (Workshop)
URL: https://arxiv.org/abs/1810.09610

This paper is really only tangentially related, in that it deals with the
intersection of lazy evaluation and imperative languages. The authors propose
a theory for precisely timing the execution of programs written in imperative
languages if parts of them were to be evaluated lazily. There's no
implementation, it seems to be just a thought experiment.

-------------------------------------------------------------------------------

(2) "Lazy Imperative Programming"
John Launchbury (Glasgow U)
ACM Workshop on State in Programming Languages 1993
URL: https://www.researchgate.net/publication/2248360_Lazy_Imperative_Programming

The author of this proposes a way to model imperative state within Haskell, which
is a purely lazily-evaluated language. At the time, the only way to implement
mutable state in Haskell was through monads (such as the IO monad), which had
the unfortunate side-effect of losing the benefits of lazy evaluation, as those
monads were always eagerly evaluated. The author proposes a language construct
"Seq", which allows modeling sequential/imperative state computations, but
allowing them to be lazily evaluated when possible.

-------------------------------------------------------------------------------

(3) "Lazy Code Motion"
Jens Knoop (Vienna UT), Olier Ruthing, Bernhard Steffen (TU Dortmund)
ACM PLDI'92
URL: https://dl.acm.org/doi/abs/10.1145/143095.143136

The classic paper on Lazy Code Motion/Partial Redundancy Elimination. The
obvious relation to our work is that it is "lazy", in the sense that it removes
redundant expression computations, replacing them by as few computations as
possible.

-------------------------------------------------------------------------------

(4) "Interprocedural partial redundancy elimination and its application to
distributed memory compilation" (why so long?)
Gargan Agrawal, Joel Haskin Saltz, Raja Das (University of Maryland, College)
URL: https://dl.acm.org/doi/abs/10.1145/223428.207157

This is probably the most closely related paper we have found so far. The
authors propose a technique that identifies pure functions which are called
in contexts where their arguments are never modified, and hoisting those calls
out to the callee function. Their optimization however focuses solely on the
scope of function calls, and bails out whenever a function's argument is
modified in a program path. Our technique therefore could actually be
complementary with theirs: after being transformed by our optimization, a
program is more likely to contain pure function calls that can be hoisted
out interprocedurally.

-------------------------------------------------------------------------------

(5) "The Theory and Practice of Transforming Call-By-Need Into Call-By-Value"
Alan Mycroft (U of Edinburgh)
International Symposium on Programming '80
URL: https://dl.acm.org/doi/10.5555/647324.721526 

This paper by is quite related to what we do, in the sense that it does the
same thing in the opposite direction. That is, it provides the theory behind
a system to find arguments that can be eagerly evaluated in languages which
are traditionally always lazily evaluated. The motivation for their work is that
call-by-value (eager evaluation) is generally cheaper to implement in most
architectures, since there is no need to pass closures across function call
boundaries. Thus, it would be profitable to use eager evaluation whenever
possible. The author proposes a system where one can compute, for a given
function: (1) whether any of its formal parameters can always be evaluated
before the call is made, across all calls of the function; and (2) whether
the computation of any of the actual parameters used across all calls of a
function are guaranteed to always terminate, thus making them "replaceable" by
the computed value eagerly. The intersection of these two sets gives a set of
arguments which can be eagerly evaluated before function calls are performed,
and replaced by their computed values rather than be passed across function
boundaries.
