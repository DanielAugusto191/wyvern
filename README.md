# Lazification of Function Arguments

In [strict programming languages](https://en.wikipedia.org/wiki/Evaluation_strategy#Strict_evaluation), parameters of functions are evaluated before these functions are invoked. In [lazy programming languages](https://en.wikipedia.org/wiki/Evaluation_strategy#Non-strict_evaluation), the evaluation happens after invocation, if the formal parameters are effectively used. Languages are strict or lazy by default, sometimes providing developers with constructs to modify this expected evaluation semantics. In this case, it is up to the programmer to decide when to use either approach. The goal of this project is to move this task to the compiler by introducing the notion of "*lazification*" of function arguments: a code transformation technique that replaces strict with lazy evaluation of parameters whenever such modification is deemed profitable.

This transformation involves a static analysis to identify function calls that are candidates for lazification, plus a code extraction technique that generates [closures](https://en.wikipedia.org/wiki/Closure_(computer_programming)) to be lazily activated. Code extraction uses an adaptation of the classic program [slicing](https://en.wikipedia.org/wiki/Program_slicing) technique adjusted for the [static single assignment](https://en.wikipedia.org/wiki/Static_single-assignment_form) (SSA) representation. If lazification is guided by profiling information, then it can deliver speedups even on traditional benchmarks that are heavily optimized.

We have implemented lazification onto LLVM 14.0, and have applied it onto hundreds of C/C++ programs from the LLVM test-suite and from [SPEC CPU2017](https://www.spec.org/cpu2017/). During this evaluation, we could observe statistically significant speedups over [clang](https://clang.llvm.org/) -O3 on some large programs, including a speedup of 11.1% on Prolang's Bison and a speedup of 4.6% on SPEC CPU2017's perlbench, which has more than 1.7 million LLVM instructions once compiled with clang -O3.
